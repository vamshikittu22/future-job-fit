---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: 
  - src/shared/contexts/JobContext.tsx
  - src/shared/types/job.ts
  - src/shared/lib/initialJobData.ts
autonomous: true

must_haves:
  truths:
    - "JobContext provides application-wide state management for job-specific data"
    - "Multiple jobs can be saved with full CRUD operations"
    - "Job data persists to localStorage with auto-save (same as ResumeContext)"
    - "Both raw job description text and structured/AI-extracted fields are stored"
    - "Components can access job state via useJob() hook"
  artifacts:
    - path: "src/shared/types/job.ts"
      provides: "TypeScript types for JobData, SavedJob, and related structures"
      exports: ["JobData", "SavedJob", "JobMetadata", "ExtractedJobField"]
    - path: "src/shared/contexts/JobContext.tsx"
      provides: "Job state management with reducer pattern"
      exports: ["JobContext", "JobProvider", "useJob"]
    - path: "src/shared/lib/initialJobData.ts"
      provides: "Initial/default job data state"
      exports: ["initialJobData"]
  key_links:
    - from: "src/shared/contexts/JobContext.tsx"
      to: "src/shared/types/job.ts"
      via: "type imports"
      pattern: "import.*from.*types/job"
    - from: "src/shared/contexts/JobContext.tsx"
      to: "localStorage"
      via: "auto-save useEffect"
      pattern: "localStorage\\.setItem\\(.*JOB_STORAGE_KEY"
    - from: "components"
      to: "JobContext"
      via: "useJob() hook"
      pattern: "const.*=.*useJob\\(\\)"
---

<objective>
Create JobContext state management system for job-specific data following the established ResumeContext patterns.

Purpose: Enable all downstream features (Cover Letter, Interview Prep) to access and manage job data (job descriptions, target roles, company info) with the same reliability and persistence as resume data.
Output: Complete JobContext with types, initial data, and full CRUD operations supporting multiple saved jobs.
</objective>

<execution_context>
@C:/Users/kittu/.config/opencode/get-shit-done/workflows/execute-plan.md
@C:/Users/kittu/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Reference existing patterns
@src/shared/contexts/ResumeContext.tsx
@src/shared/types/resume.ts
@src/shared/lib/initialData.ts

# User decisions to honor
@.planning/phases/01-foundation/01-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Job Type Definitions</name>
  <files>src/shared/types/job.ts</files>
  <action>
    Create comprehensive TypeScript types for job data management following the pattern in src/shared/types/resume.ts and src/shared/types/ats.ts.

    Types to define (per user decision - multiple jobs supported, both raw and structured data):
    
    1. ExtractedJobField - For AI-extracted structured fields from job descriptions:
       - id: string
       - fieldType: 'requirement' | 'qualification' | 'responsibility' | 'skill' | 'benefit'
       - value: string
       - confidence: number (0-1)
       - sourceSection: string (which JD section this came from)
    
    2. JobMetadata - Metadata for a job entry:
       - createdAt: string (ISO date)
       - updatedAt: string (ISO date)
       - lastAnalyzedAt?: string
       - source?: 'manual' | 'linkedin' | 'import'
       - tags?: string[]
    
    3. JobData - Core job data structure (per user decision - store both raw and structured):
       - id: string
       - title: string (job title)
       - company: string
       - location?: string
       - description: string (raw job description text)
       - extractedFields: ExtractedJobField[] (AI-extracted structured data)
       - requirements?: string[] (derived from extractedFields)
       - salaryRange?: { min?: number; max?: number; currency?: string; period?: 'hourly' | 'yearly' }
       - url?: string (job posting URL)
       - status: 'draft' | 'applied' | 'interviewing' | 'offer' | 'rejected' | 'archived'
       - metadata: JobMetadata
       - notes?: string (user notes about this job)
    
    4. SavedJob - For persisted jobs:
       - job: JobData
       - version?: number (for optimistic locking if needed later)
    
    5. JobContextValue - For the context type (see ResumeContextType pattern):
       - currentJob: JobData | null
       - savedJobs: SavedJob[]
       - setCurrentJob: (job: JobData) => void
       - addJob: (job: JobData) => void
       - updateJob: (id: string, updates: Partial<JobData>) => void
       - removeJob: (id: string) => void
       - saveCurrentJob: () => void
       - loadJob: (id: string) => void
       - clearCurrentJob: () => void
       - updateExtractedFields: (fields: ExtractedJobField[]) => void
       - addNote: (note: string) => void

    Use strict typing with proper interfaces. Add JSDoc comments for complex fields.
    Follow the same quality level as src/shared/types/ats.ts.
  </action>
  <verify>Run `npm run lint src/shared/types/job.ts` - no TypeScript errors</verify>
  <done>File exists with all type definitions, compiles without errors</done>
</task>

<task type="auto">
  <name>Task 2: Create Initial Job Data</name>
  <files>src/shared/lib/initialJobData.ts</files>
  <action>
    Create initial/default job data state following the pattern in src/shared/lib/initialData.ts.

    Export:
    1. JOB_STORAGE_KEY = 'jobBuilderDraft' (for current/draft job)
    2. SAVED_JOBS_KEY = 'jobBuilderSavedJobs' (for list of saved jobs)
    3. initialJobData: JobData - A complete JobData object with all fields initialized:
       - id: '' (empty string, will be generated on create)
       - title: ''
       - company: ''
       - location: ''
       - description: ''
       - extractedFields: []
       - requirements: []
       - salaryRange: undefined
       - url: ''
       - status: 'draft'
       - metadata: { createdAt: '', updatedAt: '', tags: [] }
       - notes: ''

    All arrays should be empty, strings empty, optional fields undefined or properly typed.
  </action>
  <verify>Run `npm run lint src/shared/lib/initialJobData.ts` - no TypeScript errors</verify>
  <done>File exists with initialJobData, types match src/shared/types/job.ts</done>
</task>

<task type="auto">
  <name>Task 3: Create JobContext with Reducer Pattern</name>
  <files>src/shared/contexts/JobContext.tsx</files>
  <action>
    Create JobContext following the ResumeContext.tsx pattern exactly.

    Implementation requirements:
    1. Use reducer pattern with JobAction type (UNION of all action types)
       - SET_CURRENT_JOB
       - ADD_JOB
       - UPDATE_JOB  
       - REMOVE_JOB
       - LOAD_JOB
       - CLEAR_CURRENT_JOB
       - UPDATE_EXTRACTED_FIELDS
       - ADD_NOTE
       - SET_SAVED_JOBS
    
    2. State structure:
       - currentJob: JobData | null
       - savedJobs: SavedJob[]
    
    3. Key features (per user decisions):
       - localStorage persistence with auto-save (same 2-second debounce as ResumeContext)
       - Multiple saved jobs support (up to 50 jobs to avoid localStorage limits)
       - Generate unique IDs using Date.now().toString(36) + Math.random().toString(36).substr(2)
    
    4. Hook functions to expose (via useJob):
       - currentJob: JobData | null
       - savedJobs: SavedJob[]
       - setCurrentJob: (job: JobData) => void
       - addJob: (job: JobData) => void (generates ID, sets createdAt)
       - updateJob: (id: string, updates: Partial<JobData>) => void
       - removeJob: (id: string) => void
       - saveCurrentJob: () => void (adds to savedJobs if not already there)
       - loadJob: (id: string) => void (loads from savedJobs into currentJob)
       - clearCurrentJob: () => void (resets to initialJobData)
       - updateExtractedFields: (fields: ExtractedJobField[]) => void
       - addNote: (note: string) => void
    
    5. Error handling:
       - Wrap localStorage operations in try/catch
       - Log errors to console (following ResumeContext pattern)
    
    6. Context provider:
       - JobProvider component wrapping children
       - useJob hook with proper error if used outside provider
    
    Import from:
    - src/shared/types/job.ts
    - src/shared/lib/initialJobData.ts
    - Use lodash/debounce for auto-save
  </action>
  <verify>
    1. Run `npm run lint src/shared/contexts/JobContext.tsx` - no TypeScript errors
    2. Verify exports: grep -E "export.*(JobContext|JobProvider|useJob)" src/shared/contexts/JobContext.tsx
  </verify>
  <done>
    JobContext.tsx exists with full reducer pattern, localStorage persistence, all CRUD operations, and proper TypeScript types. All exports are available.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation passes: `npm run build` completes without errors
2. Job types are importable: `import { JobData, useJob } from '@/shared/contexts/JobContext'`
3. JobContext can be wrapped around components and provides expected values
</verification>

<success_criteria>
- JobContext provides application-wide state for job data
- Multiple jobs can be saved and managed (CRUD operations)
- Data persists to localStorage with 2-second debounced auto-save
- useJob() hook throws error if used outside JobProvider
- All TypeScript types strictly defined with no `any` types
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`
</output>
