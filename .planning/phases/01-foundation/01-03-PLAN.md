---
phase: 01-foundation
plan: 03
type: execute
wave: 1
depends_on: []
files_modified: 
  - src/features/linkedin-sync/services/linkedinAPI.ts
  - src/features/linkedin-sync/services/oauth.ts
  - src/features/linkedin-sync/services/index.ts
autonomous: true

must_haves:
  truths:
    - "LinkedIn API service stubs exist for OAuth flow and profile operations"
    - "OAuth implementation uses PKCE flow (per user decision - secret stays server-side)"
    - "Supabase Edge Function handles token exchange securely"
    - "Tokens are stored in memory only (per user decision - cleared on refresh)"
    - "Graceful degradation when LinkedIn data is limited"
  artifacts:
    - path: "src/features/linkedin-sync/services/oauth.ts"
      provides: "OAuth 2.0 + PKCE flow implementation"
      exports: ["initiateOAuthFlow", "handleOAuthCallback", "generatePKCE", "LINKEDIN_SCOPES"]
    - path: "src/features/linkedin-sync/services/linkedinAPI.ts"
      provides: "LinkedIn API client with profile operations"
      exports: ["LinkedInAPIClient", "fetchBasicProfile", "disconnectLinkedIn"]
    - path: "src/features/linkedin-sync/services/index.ts"
      provides: "Service exports barrel file"
      exports: ["* from oauth", "* from linkedinAPI"]
  key_links:
    - from: "src/features/linkedin-sync/services/oauth.ts"
      to: "Supabase Edge Function"
      via: "supabase.functions.invoke('linkedin-oauth')"
      pattern: "supabase\\.functions\\.invoke"
    - from: "src/features/linkedin-sync/services/linkedinAPI.ts"
      to: "src/features/linkedin-sync/types.ts"
      via: "type imports"
      pattern: "import.*LinkedIn"
---

<objective>
Create API service stubs for LinkedIn OAuth 2.0 + PKCE flow and profile operations.

Purpose: Establish the foundation for LinkedIn Profile Sync (Phase 3) with secure OAuth implementation that keeps secrets server-side and stores tokens in memory only. Provides graceful degradation for LinkedIn API limitations.
Output: Complete LinkedIn API service layer with OAuth flow, token management, and profile fetching stubs.
</objective>

<execution_context>
@C:/Users/kittu/.config/opencode/get-shit-done/workflows/execute-plan.md
@C:/Users/kittu/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Reference existing patterns
@src/shared/api/resumeAI.ts
@src/shared/integrations/supabase/client.ts

# Types to use
@src/features/linkedin-sync/types.ts

# User decisions
@.planning/phases/01-foundation/01-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create OAuth Service with PKCE Flow</name>
  <files>src/features/linkedin-sync/services/oauth.ts</files>
  <action>
    Create OAuth 2.0 + PKCE implementation for LinkedIn following security best practices (per user decision - secret stays server-side).

    Implementation details:

    1. Constants:
       - LINKEDIN_AUTH_URL = 'https://www.linkedin.com/oauth/v2/authorization'
       - LINKEDIN_SCOPES = ['openid', 'profile', 'email'] (basic profile only - per research, no partner program needed)
       - LOCAL_STORAGE_KEY = 'linkedin_oauth_state' (for PKCE state, not tokens)

    2. PKCE Helper Functions:
       - generatePKCE(): { codeVerifier: string; codeChallenge: string; state: string }
         * codeVerifier: random string (128 chars, alphanumeric + -._~)
         * codeChallenge: base64url(SHA256(codeVerifier))
         * state: random string for CSRF protection
         
    3. initiateOAuthFlow(): void
       - Generate PKCE params
       - Store state and codeVerifier in localStorage (temporary, will be cleared after callback)
       - Build authorization URL with:
         * client_id (from env or placeholder for now)
         * redirect_uri (must match LinkedIn app config)
         * response_type: 'code'
         * scope: LINKEDIN_SCOPES
         * state: PKCE state
         * code_challenge: PKCE codeChallenge
         * code_challenge_method: 'S256'
       - Redirect browser to LinkedIn auth URL

    4. handleOAuthCallback(code: string, state: string): Promise<LinkedInOAuthResponse>
       - Retrieve stored state and codeVerifier from localStorage
       - Validate state matches (CSRF protection)
       - Call Supabase Edge Function 'linkedin-oauth' with:
         * grant_type: 'authorization_code'
         * code: authorization code from callback
         * code_verifier: from localStorage
         * redirect_uri: same as initiate
       - Clear localStorage state after successful exchange
       - Return LinkedInOAuthResponse
       - Handle errors gracefully with specific error messages

    5. Error Handling:
       - Create LinkedInOAuthError class extending Error
       - Handle specific errors: invalid_grant, access_denied, invalid_request
       - Provide user-friendly error messages

    Import from:
    - src/features/linkedin-sync/types.ts
    - src/shared/integrations/supabase/client.ts
    
    Note: Edge Function 'linkedin-oauth' doesn't exist yet - this is a stub that will call it when built in Phase 3. Use placeholder that logs "Edge function call would happen here" for now.
  </action>
  <verify>
    1. Run `npm run lint src/features/linkedin-sync/services/oauth.ts` - no TypeScript errors
    2. Verify PKCE generation works: generatePKCE() returns valid code challenge
    3. Verify exports: grep -E "export.*(initiateOAuthFlow|handleOAuthCallback|generatePKCE)" src/features/linkedin-sync/services/oauth.ts
  </verify>
  <done>
    OAuth service exists with PKCE implementation, proper error handling, and Supabase Edge Function integration stubs.
    All functions exported and TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create LinkedIn API Client</name>
  <files>src/features/linkedin-sync/services/linkedinAPI.ts</files>
  <action>
    Create LinkedIn API client for profile operations with in-memory token storage (per user decision - tokens in memory only).

    Implementation details:

    1. Token Management (In-Memory Only - per user decision):
       - Module-level variables (NOT exported):
         * let accessToken: string | null = null
         * let tokenExpiresAt: number | null = null
         * let cachedProfile: LinkedInBasicProfile | null = null
       - Helper functions:
         * setAccessToken(token: string, expiresIn: number): void (sets module vars)
         * getAccessToken(): string | null (returns token if not expired)
         * isTokenValid(): boolean (checks expiration)
         * clearTokens(): void (clears all module vars)

    2. LinkedInAPIClient class:
       - Private methods:
         * makeRequest(endpoint: string, options?: RequestInit): Promise<any>
           - Adds Authorization: Bearer {token} header
           - Handles 401 by clearing tokens and throwing
           - Handles rate limiting (429) with retry logic
       
       - Public methods (stubs for now - return mock data):
         * fetchBasicProfile(): Promise<LinkedInBasicProfile>
           - Calls /v2/userinfo (OpenID Connect endpoint for basic profile)
           - Returns: id, firstName, lastName, headline, profilePictureUrl
           - Graceful degradation: if field missing, returns partial data
         
         * fetchEmail(): Promise<string | null>
           - Calls /v2/emailAddress (requires email scope)
           - Returns email or null if not available
         
         * fetchFullProfile(): Promise<LinkedInProfile>
           - Composes basic profile + email
           - Creates LinkedInProfile with mappedFields
           - Note: Without partner program, this is limited - document this limitation
         
         * disconnect(): Promise<void>
           - Clears all tokens from memory
           - Calls LinkedIn token revocation endpoint (if available)
           - Clears cached profile

    3. Convenience Functions (exported at module level):
       - fetchBasicProfile(): Promise<LinkedInBasicProfile> (uses singleton client)
       - disconnectLinkedIn(): Promise<void> (uses singleton client)
       - getConnectionState(): LinkedInConnectionState (checks token validity, returns state object)

    4. Mock Mode (for development):
       - If VITE_LINKEDIN_MOCK_MODE=true in env, return mock data instead of making API calls
       - Mock data should match LinkedInBasicProfile structure
       - Useful for UI development without LinkedIn credentials

    5. Error Handling:
       - LinkedInAPIError class for API-specific errors
       - Distinguish between: network error, auth error, rate limit, not found
       - Provide actionable error messages

    Import from:
    - src/features/linkedin-sync/types.ts
    - src/shared/integrations/supabase/client.ts (for token refresh via Edge Function)
  </action>
  <verify>
    1. Run `npm run lint src/features/linkedin-sync/services/linkedinAPI.ts` - no TypeScript errors
    2. Verify singleton pattern: client is instantiated at module level
    3. Verify exports: grep -E "export.*(LinkedInAPIClient|fetchBasicProfile|disconnectLinkedIn|getConnectionState)" src/features/linkedin-sync/services/linkedinAPI.ts
    4. Verify no token persistence: grep -v "localStorage.*token" src/features/linkedin-sync/services/linkedinAPI.ts
  </verify>
  <done>
    LinkedIn API client exists with in-memory token storage, profile fetching stubs, graceful degradation, and proper error handling.
    Tokens are NOT persisted to localStorage (verified by code review).
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Service Index Barrel File</name>
  <files>src/features/linkedin-sync/services/index.ts</files>
  <action>
    Create barrel file to export all LinkedIn services from a single import location.

    Contents:
    ```typescript
    // OAuth flow
    export {
      initiateOAuthFlow,
      handleOAuthCallback,
      generatePKCE,
      LINKEDIN_SCOPES,
      LinkedInOAuthError,
    } from './oauth';

    // API Client
    export {
      LinkedInAPIClient,
      fetchBasicProfile,
      disconnectLinkedIn,
      getConnectionState,
      LinkedInAPIError,
    } from './linkedinAPI';
    ```

    This allows clean imports:
    `import { initiateOAuthFlow, fetchBasicProfile } from '@/features/linkedin-sync/services';`
  </action>
  <verify>
    1. Run `npm run lint src/features/linkedin-sync/services/index.ts` - no TypeScript errors
    2. Verify all exports: grep -E "export.*from" src/features/linkedin-sync/services/index.ts | wc -l >= 2
  </verify>
  <done>Barrel file exists with clean exports from all service modules</done>
</task>

</tasks>

<verification>
1. TypeScript compilation passes: `npm run build` completes without errors
2. Services can be imported: `import { initiateOAuthFlow, LinkedInAPIClient } from '@/features/linkedin-sync/services'`
3. PKCE generation produces valid code challenge/verifier pairs
4. No token persistence to localStorage (security requirement)
</verification>

<success_criteria>
- OAuth 2.0 + PKCE flow implemented with proper CSRF protection
- Token exchange handled via Supabase Edge Function (stub for now)
- Tokens stored in memory only (verified by code inspection)
- LinkedIn API client provides profile fetching with graceful degradation
- Error handling distinguishes auth errors, network errors, rate limits
- Mock mode available for development without LinkedIn credentials
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
