---
phase: 00-hardening
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - vite.config.ts
  - src/shared/lib/storage/compression.ts
autonomous: true

must_haves:
  truths:
    - Duplicate dependencies removed
    - Bundle size reduced by >10%
    - Storage compression layer implemented
    - No runtime errors from dependency changes
  artifacts:
    - path: "package.json"
      provides: "Cleaned dependencies"
    - path: "src/shared/lib/storage/compression.ts"
      provides: "Compression utilities for localStorage"
      exports: ["compress", "decompress", " CompressionError"]
  key_links:
    - from: "Compression utilities"
      to: "ResumeContext/JobContext"
      via: "localStorage persistence"
---

<objective>
Remove duplicate dependencies and implement storage compression to prevent 5MB localStorage limit issues.

Purpose: ATS Simulation 2.0 will add complexity; we need clean dependencies and storage headroom.
Output: Deduplicated dependencies, <10% bundle reduction, compression layer for localStorage.
</objective>

<execution_context>
@C:/Users/kittu/.config/opencode/get-shit-done/workflows/execute-plan.md
</execution_context>

<context>
@package.json
@.planning/STATE.md

## Known Issues
- Duplicate dependencies: @dnd-kit + @hello-pangea/dnd
- Bundle size: 2MB+ (includes Pyodide)
- Storage risk: localStorage 5MB limit may be hit with large resumes

## Dependency Audit Needed
- Check for duplicate drag-and-drop libraries
- Check for unused dependencies
- Check for outdated packages
</context>

<tasks>

<task type="auto">
  <name>Task 1: Audit and Remove Duplicate Dependencies</name>
  <files>package.json</files>
  <action>
    Remove duplicate drag-and-drop dependencies:

    1. Identify which library is actually used:
       ```bash
       grep -r "@dnd-kit" src/ --include="*.ts" --include="*.tsx" | head -20
       grep -r "@hello-pangea/dnd" src/ --include="*.ts" --include="*.tsx" | head -20
       ```

    2. Decision criteria:
       - Which has more usage?
       - Which is more actively maintained?
       - @hello-pangea/dnd is maintained fork of react-beautiful-dnd
       - @dnd-kit is newer, more modular

    3. Keep one, remove the other:
       - If keeping @dnd-kit: Remove @hello-pangea/dnd
       - If keeping @hello-pangea/dnd: Remove @dnd-kit packages

    4. Update all imports to use the kept library:
       ```bash
       find src -name "*.tsx" -exec sed -i 's/@hello-pangea\/dnd/@dnd-kit/g' {} \;
       # or vice versa
       ```

    5. Test drag-and-drop functionality still works:
       - Resume wizard step navigation
       - Any reorderable lists

    6. Run `npm install` after package.json changes
  </action>
  <verify>
    1. Only one drag-and-drop library in package.json
    2. `npm run build` passes
    3. Drag-and-drop functionality tested manually
  </verify>
  <done>
    Duplicate dependencies removed. Only one DnD library remains.
    Build passes, functionality preserved.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Storage Compression Layer</name>
  <files>
    src/shared/lib/storage/compression.ts
    src/shared/lib/storage/index.ts
  </files>
  <action>
    Create compression utilities to prevent localStorage 5MB limit:

    1. Install lz-string for compression:
       ```bash
       npm install lz-string
       npm install -D @types/lz-string
       ```

    2. Create compression utilities:
       ```typescript
       // src/shared/lib/storage/compression.ts
       import LZString from 'lz-string';

       export class CompressionError extends Error {
         constructor(message: string) {
           super(message);
           this.name = 'CompressionError';
         }
       }

       export function compress(data: string): string {
         try {
           return LZString.compressToUTF16(data);
         } catch (error) {
           throw new CompressionError(`Failed to compress: ${error}`);
         }
       }

       export function decompress(compressed: string): string {
         try {
           const result = LZString.decompressFromUTF16(compressed);
           if (result === null) {
             throw new CompressionError('Decompression returned null');
           }
           return result;
         } catch (error) {
           throw new CompressionError(`Failed to decompress: ${error}`);
         }
       }

       export function getSizeInKB(data: string): number {
         return new Blob([data]).size / 1024;
       }

       export function estimateCompressionRatio(data: string): number {
         const compressed = compress(data);
         return getSizeInKB(data) / getSizeInKB(compressed);
       }
       ```

    3. Create barrel file:
       ```typescript
       // src/shared/lib/storage/index.ts
       export {
         compress,
         decompress,
         CompressionError,
         getSizeInKB,
         estimateCompressionRatio
       } from './compression';
       ```

    4. Create safe storage wrapper:
       ```typescript
       // src/shared/lib/storage/safeStorage.ts
       import { compress, decompress, CompressionError } from './compression';

       const STORAGE_QUOTA = 5 * 1024 * 1024; // 5MB
       const WARNING_THRESHOLD = 4 * 1024 * 1024; // 4MB

       export function setItem(key: string, value: string): void {
         const compressed = compress(value);
         
         // Check total storage usage
         let totalUsage = 0;
         for (let i = 0; i < localStorage.length; i++) {
           const k = localStorage.key(i);
           if (k) {
             totalUsage += localStorage.getItem(k)?.length || 0;
           }
         }

         if (totalUsage + compressed.length > STORAGE_QUOTA) {
           throw new CompressionError(
             `Storage quota exceeded. Current: ${(totalUsage / 1024).toFixed(2)}KB, ` +
             `Adding: ${(compressed.length / 1024).toFixed(2)}KB`
           );
         }

         localStorage.setItem(key, compressed);
       }

       export function getItem(key: string): string | null {
         const compressed = localStorage.getItem(key);
         if (!compressed) return null;
         
         try {
           return decompress(compressed);
         } catch {
           // If decompression fails, try returning raw (backward compat)
           return compressed;
         }
       }
       ```

    5. Test compression ratios:
       - Large resume data should compress 3-5x
       - Verify decompression round-trip
  </action>
  <verify>
    1. `npm run lint src/shared/lib/storage/` - no errors
    2. Compression test: large JSON compresses 3x+
    3. Round-trip test: compress â†’ decompress equals original
  </verify>
  <done>
    Compression layer implemented. Utilities tested and working.
    Compression ratio 3-5x for typical resume data.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate Compression into Contexts</name>
  <files>
    src/shared/contexts/ResumeContext.tsx
    src/shared/contexts/JobContext.tsx
  </files>
  <action>
    Update contexts to use compressed storage:

    1. Import safe storage utilities:
       ```typescript
       import { setItem, getItem } from '@/shared/lib/storage/safeStorage';
       ```

    2. Update ResumeContext storage:
       ```typescript
       // Replace localStorage.setItem with:
       setItem('resumeBuilderDraft', JSON.stringify(resumeData));
       
       // Replace localStorage.getItem with:
       const saved = getItem('resumeBuilderDraft');
       ```

    3. Update JobContext storage:
       ```typescript
       // Replace localStorage.setItem with:
       setItem('fjf_job_data', JSON.stringify(state));
       ```

    4. Add migration logic for existing uncompressed data:
       ```typescript
       // Try compressed first, fall back to uncompressed
       function loadWithMigration(key: string): string | null {
         try {
           return getItem(key); // Try compressed
         } catch {
           // Fall back to raw localStorage
           return localStorage.getItem(key);
         }
       }
       ```

    5. Add storage metrics to dev mode (God Mode console):
       ```typescript
       if (import.meta.env.DEV) {
         const usage = calculateStorageUsage();
         console.log(`Storage: ${(usage / 1024).toFixed(2)}KB / 5120KB`);
       }
       ```

    6. Test full resume save/load cycle
  </action>
  <verify>
    1. Resume saves successfully with compression
    2. Resume loads correctly after page refresh
    3. Storage usage visible in dev console
    4. No data loss in migration
  </verify>
  <done>
    Compression integrated into ResumeContext and JobContext.
    Data persistence works with compression enabled.
  </done>
</task>

<task type="auto">
  <name>Task 4: Bundle Size Optimization</name>
  <files>vite.config.ts</files>
  <action>
    Analyze and optimize bundle size:

    1. Install bundle analyzer:
       ```bash
       npm install -D rollup-plugin-visualizer
       ```

    2. Update vite.config.ts:
       ```typescript
       import { visualizer } from 'rollup-plugin-visualizer';

       export default defineConfig({
         // ... existing config
         build: {
           rollupOptions: {
             output: {
               manualChunks: {
                 // Separate Pyodide into its own chunk
                 pyodide: ['pyodide'],
                 // Vendor chunk for heavy dependencies
                 vendor: ['react', 'react-dom', 'react-router-dom'],
                 // UI chunk
                 ui: ['@radix-ui/react-dialog', '@radix-ui/react-dropdown-menu', /* etc */],
               }
             }
           }
         },
         plugins: [
           // ... existing plugins
           visualizer({
             open: true,
             gzipSize: true,
             brotliSize: true,
           })
         ]
       });
       ```

    3. Analyze bundle and identify:
       - Largest dependencies
       - Duplicate code
       - Tree-shaking opportunities

    4. Optimize imports where possible:
       - Use specific imports instead of barrel imports
       - Lazy load heavy components

    5. Build and compare bundle sizes:
       ```bash
       npm run build
       # Check dist/ folder size
       du -sh dist/
       ```

    6. Target: >10% bundle size reduction
  </action>
  <verify>
    1. Build completes successfully
    2. Bundle size reduced by >10%
    3. Analyzer report generated (stats.html)
  </verify>
  <done>
    Bundle optimized with code splitting. Size reduced >10%.
    Analysis report available.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes
2. Bundle size reduced by >10%
3. Storage compression works (3-5x ratio)
4. Resume/Job data persists correctly
5. No duplicate dependencies
</verification>

<success_criteria>
- Duplicate dependencies removed
- Bundle size reduced >10%
- Storage compression layer implemented
- Contexts use compressed storage
- No data loss or runtime errors
</success_criteria>

<output>
After completion, create `.planning/phases/00-hardening/00-02-SUMMARY.md`
</output>
