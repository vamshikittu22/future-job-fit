---
phase: 00-hardening
plan: 02
type: execute
wave: 1
depends_on: ['00-01']
files_modified:
  - package.json
  - vite.config.ts
  - src/shared/lib/storage/compression.ts
  - src/shared/lib/storage/quota.ts
autonomous: true

must_haves:
  truths:
    - Single DnD library (no duplicates)
    - Storage quota uses real byte size (not .length)
    - LZ-String compression integrated
    - Pyodide chunking tested (revert if WASM breaks)
    - Bundle reduced >10%
  artifacts:
    - path: "src/shared/lib/storage/compression.ts"
      provides: "Compression utilities with UTF16"
      exports: ["compress", "decompress"]
    - path: "src/shared/lib/storage/quota.ts"
      provides: "Real byte size quota checking"
      exports: ["getLocalStorageSize", "checkQuota"]
  key_links:
    - from: "Compression utilities"
      to: "ResumeContext/JobContext"
      via: "localStorage persistence"
---

<objective>
Remove duplicate dependencies and implement storage compression with correct byte-size quota detection.

Purpose: ATS Simulation 2.0 adds complexity; we need clean dependencies and accurate storage monitoring.
Output: Deduplicated deps, correct quota detection, compression layer.
</objective>

<execution_context>
@C:/Users/kittu/.config/opencode/get-shit-done/workflows/execute-plan.md
</execution_context>

<context>
@package.json

## Known Issues
- Duplicate DnD libraries: @dnd-kit + @hello-pangea/dnd
- Incorrect storage size: using .length instead of byte size
- Bundle: 2MB+ (includes Pyodide)

## DnD Library Decision
Decision rule:
- Simple sortable lists → use @dnd-kit
- Heavy reorder UI → use @hello-pangea/dnd

## Storage Quota (CORRECTED)
Must use actual byte size, not string length.

## Pyodide Warning
If chunking breaks WASM resolution → REVERT immediately.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Remove Duplicate DnD Library</name>
  <files>package.json</files>
  <action>
    Audit and keep only ONE drag-and-drop library:

    1. Check current usage:
       ```bash
       grep -r "@dnd-kit" src/ --include="*.tsx" | wc -l
       grep -r "@hello-pangea/dnd" src/ --include="*.tsx" | wc -l
       ```

    2. Decision based on usage count:
       - If @dnd-kit has more imports → keep @dnd-kit
       - If @hello-pangea/dnd has more imports → keep @hello-pangea/dnd
       - If tied → keep @dnd-kit (lighter, more modular)

    3. Remove the other from package.json

    4. Update ALL imports to use kept library:
       ```bash
       # Example if keeping @dnd-kit
       find src -name "*.tsx" -exec sed -i 's/@hello-pangea\/dnd/@dnd-kit/g' {} \;
       ```

    5. Manual fix: Update import statements to match library API

    6. Test drag-and-drop:
       - Resume wizard step navigation
       - Any reorderable lists
       - Verify no runtime errors

    7. Run npm install
  </action>
  <verify>
    1. Only one DnD library in package.json dependencies
    2. npm run build passes
    3. Drag-and-drop functionality works manually
    4. No import errors in console
  </verify>
  <done>
    Single DnD library selected and integrated.
    Duplicate removed, functionality preserved.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix Storage Size Calculation (CORRECT)</name>
  <files>src/shared/lib/storage/quota.ts</files>
  <action>
    Create correct storage quota utilities using real byte size:

    ```typescript
    // src/shared/lib/storage/quota.ts
    
    /**
     * Get actual byte size of localStorage (not string length)
     * CORRECT: Uses Blob to calculate real UTF-16 byte size
     */
    export function getLocalStorageSize(): number {
      let total = 0;
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key) {
          const value = localStorage.getItem(key) || '';
          // Blob calculates actual byte size, not character count
          total += new Blob([key + value]).size;
        }
      }
      return total;
    }

    export const STORAGE_QUOTA = 5 * 1024 * 1024; // 5MB
    export const WARNING_THRESHOLD = 4 * 1024 * 1024; // 4MB

    export interface QuotaStatus {
      used: number;
      total: number;
      remaining: number;
      percentUsed: number;
      warning: boolean;
      critical: boolean;
    }

    export function getQuotaStatus(): QuotaStatus {
      const used = getLocalStorageSize();
      const total = STORAGE_QUOTA;
      const remaining = total - used;
      const percentUsed = (used / total) * 100;
      
      return {
        used,
        total,
        remaining,
        percentUsed,
        warning: used > WARNING_THRESHOLD,
        critical: used > total * 0.95
      };
    }

    export function checkQuota(neededBytes: number): {
      allowed: boolean;
      reason?: string;
    } {
      const status = getQuotaStatus();
      
      if (status.used + neededBytes > STORAGE_QUOTA) {
        return {
          allowed: false,
          reason: `Need ${neededBytes} bytes, only ${status.remaining} available`
        };
      }
      
      return { allowed: true };
    }

    export function formatBytes(bytes: number): string {
      if (bytes < 1024) return `${bytes}B`;
      if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)}KB`;
      return `${(bytes / (1024 * 1024)).toFixed(2)}MB`;
    }
    ```

    Export from index.ts
  </action>
  <verify>
    1. getLocalStorageSize() uses Blob (not .length)
    2. Returns accurate byte count
    3. Quota calculations correct
  </verify>
  <done>
    Correct byte-size quota detection implemented.
    No more .length approximation errors.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement LZ-String Compression</name>
  <files>
    src/shared/lib/storage/compression.ts
    src/shared/lib/storage/index.ts
  </files>
  <action>
    Implement storage compression with LZ-String:

    1. Install dependency:
       ```bash
       npm install lz-string
       npm install -D @types/lz-string
       ```

    2. Create compression utilities:
       ```typescript
       // src/shared/lib/storage/compression.ts
       import LZString from 'lz-string';

       export class CompressionError extends Error {
         constructor(message: string) {
           super(message);
           this.name = 'CompressionError';
         }
       }

       /**
        * Compress string using LZ-String UTF16
        * NOTE: Compression is for storage quota, not security
        */
       export function compress(data: string): string {
         try {
           // UTF16 compression gives better ratio for typical text
           return LZString.compressToUTF16(data);
         } catch (error) {
           throw new CompressionError(`Compression failed: ${error}`);
         }
       }

       export function decompress(compressed: string): string {
         try {
           const result = LZString.decompressFromUTF16(compressed);
           if (result === null) {
             throw new CompressionError('Decompression returned null');
           }
           return result;
         } catch (error) {
           // Fallback: return raw (backward compatibility)
           console.warn('Decompression failed, returning raw data');
           return compressed;
         }
       }

       export function getCompressionRatio(original: string): number {
         const compressed = compress(original);
         const originalBytes = new Blob([original]).size;
         const compressedBytes = new Blob([compressed]).size;
         return originalBytes / compressedBytes;
       }
       ```

    3. Create safe storage wrapper:
       ```typescript
       // src/shared/lib/storage/safeStorage.ts
       import { compress, decompress } from './compression';
       import { checkQuota, getQuotaStatus } from './quota';

       export function setItemCompressed(key: string, value: string): void {
         const compressed = compress(value);
         const check = checkQuota(new Blob([compressed]).size);
         
         if (!check.allowed) {
           throw new Error(`Storage quota exceeded: ${check.reason}`);
         }
         
         localStorage.setItem(key, compressed);
       }

       export function getItemCompressed(key: string): string | null {
         const compressed = localStorage.getItem(key);
         if (!compressed) return null;
         return decompress(compressed);
       }
       ```

    4. Update exports in index.ts
  </action>
  <verify>
    1. Compression ratio 3-5x for typical resume data
    2. Round-trip: compress → decompress equals original
    3. Quota check uses correct byte size
  </verify>
  <done>
    LZ-String compression integrated.
    Note: Compression for quota, not security.
  </done>
</task>

<task type="auto">
  <name>Task 4: Test Pyodide Chunking (CRITICAL)</name>
  <files>vite.config.ts</files>
  <action>
    Test bundle optimization with Pyodide safety:

    1. Current vite.config.ts - check if Pyodide is in manualChunks:
       ```typescript
       build: {
         rollupOptions: {
           output: {
             manualChunks: {
               pyodide: ['pyodide'],
               // ... other chunks
             }
           }
         }
       }
       ```

    2. IF manualChunks includes pyodide:
       ```bash
       npm run build
       npm run preview
       ```
       
       Test ALL of these:
       - Initial page load
       - Navigate to job optimizer
       - Trigger ATS scoring (loads Pyodide)
       - Wait for WASM load
       - Run offline mode (disconnect network)
       - Refresh page, verify cache

    3. If ANY of these fail:
       ```typescript
       // REVERT: Remove pyodide from manualChunks
       // Pyodide must load as original chunk
       ```

    4. If all pass:
       Keep chunking but add comment:
       ```typescript
       manualChunks: {
         // Pyodide chunking verified working - DO NOT CHANGE without testing
         pyodide: ['pyodide'],
       }
       ```

    5. Install bundle analyzer:
       ```bash
       npm install -D rollup-plugin-visualizer
       ```
       Add to vite.config.ts for analysis

    6. Measure bundle size:
       ```bash
       npm run build
       du -sh dist/
       ```
       Target: >10% reduction
  </action>
  <verify>
    1. Pyodide loads correctly in all test scenarios
    2. WASM resolves without errors
    3. Offline mode works
    4. Bundle size reduced >10%
    5. If Pyodide breaks → revert chunking
  </verify>
  <done>
    Bundle optimized. Pyodide stable.
    Size reduced >10% OR chunking reverted.
  </done>
</task>

<task type="auto">
  <name>Task 5: Integrate Compression into Contexts</name>
  <files>
    src/shared/contexts/ResumeContext.tsx
    src/shared/contexts/JobContext.tsx
  </files>
  <action>
    Update contexts to use compressed storage:

    1. Import safe storage:
       ```typescript
       import { setItemCompressed, getItemCompressed } from '@/shared/lib/storage';
       ```

    2. Update ResumeContext save:
       ```typescript
       // Replace localStorage.setItem
       setItemCompressed('resumeBuilderDraft', JSON.stringify(resumeData));
       ```

    3. Update ResumeContext load:
       ```typescript
       // Replace localStorage.getItem
       const saved = getItemCompressed('resumeBuilderDraft');
       ```

    4. Update JobContext similarly for 'fjf_job_data'

    5. Add migration for existing uncompressed data:
       ```typescript
       // Try compressed first, fallback to raw
       function loadWithMigration(key: string): string | null {
         const compressed = localStorage.getItem(key);
         if (!compressed) return null;
         
         try {
           // Try decompress
           return decompress(compressed);
         } catch {
           // Fallback: might be uncompressed legacy data
           return compressed;
         }
       }
       ```

    6. Add dev mode storage metrics:
       ```typescript
       if (import.meta.env.DEV) {
         const status = getQuotaStatus();
         console.log(
           `Storage: ${formatBytes(status.used)} / ${formatBytes(status.total)} ` +
           `(${status.percentUsed.toFixed(1)}%)`
         );
       }
       ```

    7. Test save/load cycle
  </action>
  <verify>
    1. Resume saves with compression
    2. Resume loads after refresh
    3. Dev console shows storage metrics
    4. Quota warnings appear when >80%
  </verify>
  <done>
    Compression integrated into contexts.
    Storage metrics visible in dev mode.
  </done>
</task>

</tasks>

<verification>
1. Single DnD library (no duplicates)
2. getLocalStorageSize() uses Blob (correct bytes)
3. LZ-String compression working (3-5x ratio)
4. Pyodide loads correctly (or chunking reverted)
5. Bundle size reduced >10%
6. Contexts use compressed storage
</verification>

<success_criteria>
- One DnD library only
- Correct byte-size quota detection
- LZ-String compression integrated
- Pyodide stable (chunked or original)
- Bundle reduced >10%
- Storage metrics in dev mode
</success_criteria>

<output>
After completion, create `.planning/phases/00-hardening/00-02-SUMMARY.md`
</output>
