---
phase: 00-hardening
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/shared/lib/storage/schemaVersion.ts
  - src/shared/lib/storage/migrate.ts
  - src/shared/lib/storage/index.ts
autonomous: true

must_haves:
  truths:
    - Storage schema versioning system implemented
    - Migration system handles version upgrades
    - No data loss during version transitions
    - Version mismatch detected and handled
  artifacts:
    - path: "src/shared/lib/storage/schemaVersion.ts"
      provides: "Schema version management"
      exports: ["STORAGE_VERSION", "getStorageVersion", "validateStorage"]
    - path: "src/shared/lib/storage/migrate.ts"
      provides: "Migration utilities"
      exports: ["runMigration", "MigrationError"]
  key_links:
    - from: "Storage contexts"
      to: "Schema version system"
      via: "migrate on load"
---

<objective>
Implement storage versioning and migration system to prevent data loss when schema changes.

Purpose: ATS Simulation 2.0 will evolve data structures. We need safe migration paths.
Output: Versioned storage with automatic migration, no data loss guarantees.
</objective>

<execution_context>
@C:/Users/kittu/.config/opencode/get-shit-done/workflows/execute-plan.md
</execution_context>

<context>
@src/shared/lib/storage/
@src/shared/types/

## Current State
- Storage keys: 'resumeBuilderDraft', 'fjf_job_data', etc.
- No versioning — schema changes could break existing data
- Types are evolving (CoverLetter, JobData, etc.)

## Risk
- Schema change without migration = data loss
- Users lose resumes on app updates
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Schema Version System</name>
  <files>
    src/shared/lib/storage/schemaVersion.ts
  </files>
  <action>
    Create versioning system for storage schema:

    1. Define version constants:
       ```typescript
       // src/shared/lib/storage/schemaVersion.ts
       export const STORAGE_VERSION = {
         CURRENT: 2,  // Increment on breaking schema changes
         MIN_SUPPORTED: 1,
       } as const;

       export type StorageVersion = number;

       export interface VersionedData<T> {
         version: StorageVersion;
         migratedAt?: string;
         data: T;
       }
       ```

    2. Create version detection:
       ```typescript
       export function getStorageVersion(key: string): StorageVersion | null {
         const raw = localStorage.getItem(key);
         if (!raw) return null;
         
         try {
           const parsed = JSON.parse(raw);
           // Check if versioned format
           if (parsed && typeof parsed.version === 'number') {
             return parsed.version;
           }
           // Legacy unversioned data
           return 1;
         } catch {
           return 1; // Assume legacy if parse fails
         }
       }

       export function isVersionSupported(version: StorageVersion): boolean {
         return version >= STORAGE_VERSION.MIN_SUPPORTED && 
                version <= STORAGE_VERSION.CURRENT;
       }
       ```

    3. Create validation:
       ```typescript
       export function validateStorage(key: string): {
         valid: boolean;
         currentVersion: StorageVersion | null;
         needsMigration: boolean;
       } {
         const currentVersion = getStorageVersion(key);
         
         if (currentVersion === null) {
           return { valid: true, currentVersion: null, needsMigration: false };
         }
         
         if (!isVersionSupported(currentVersion)) {
           return { 
             valid: false, 
             currentVersion, 
             needsMigration: false 
           };
         }
         
         return {
           valid: true,
           currentVersion,
           needsMigration: currentVersion < STORAGE_VERSION.CURRENT
         };
       }
       ```

    4. Export from index.ts
  </action>
  <verify>
    1. `npm run lint` passes
    2. Version detection works for new and legacy formats
    3. Validation correctly identifies migration needs
  </verify>
  <done>
    Schema version system implemented with version detection and validation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Migration Framework</name>
  <files>
    src/shared/lib/storage/migrate.ts
    src/shared/lib/storage/migrations/
  </files>
  <action>
    Create migration system for schema upgrades:

    1. Define migration interface:
       ```typescript
       // src/shared/lib/storage/migrate.ts
       export interface Migration<TFrom, TTo> {
         fromVersion: number;
         toVersion: number;
         migrate: (data: TFrom) => TTo;
       }

       export class MigrationError extends Error {
         constructor(
           message: string,
           public readonly fromVersion: number,
           public readonly toVersion: number
         ) {
           super(message);
           this.name = 'MigrationError';
         }
       }
       ```

    2. Create migration registry:
       ```typescript
       const migrations: Migration<unknown, unknown>[] = [];

       export function registerMigration<TFrom, TTo>(
         migration: Migration<TFrom, TTo>
       ): void {
         migrations.push(migration);
       }

       export function getMigrations(
         fromVersion: number, 
         toVersion: number
       ): Migration<unknown, unknown>[] {
         return migrations
           .filter(m => m.fromVersion >= fromVersion && m.toVersion <= toVersion)
           .sort((a, b) => a.fromVersion - b.fromVersion);
       }
       ```

    3. Create migration runner:
       ```typescript
       export function runMigration<T>(
         data: unknown,
         fromVersion: number,
         toVersion: number
       ): T {
         const path = getMigrations(fromVersion, toVersion);
         
         if (path.length === 0) {
           throw new MigrationError(
             `No migration path from v${fromVersion} to v${toVersion}`,
             fromVersion,
             toVersion
           );
         }

         let current = data;
         for (const migration of path) {
           try {
             current = migration.migrate(current);
           } catch (error) {
             throw new MigrationError(
               `Migration v${migration.fromVersion}→v${migration.toVersion} failed: ${error}`,
               migration.fromVersion,
               migration.toVersion
             );
           }
         }

         return current as T;
       }
       ```

    4. Create versioned storage wrapper:
       ```typescript
       export function saveVersioned<T>(
         key: string, 
         data: T, 
         version: number = STORAGE_VERSION.CURRENT
       ): void {
         const versioned: VersionedData<T> = {
           version,
           migratedAt: new Date().toISOString(),
           data
         };
         localStorage.setItem(key, JSON.stringify(versioned));
       }

       export function loadVersioned<T>(
         key: string,
         targetVersion: number = STORAGE_VERSION.CURRENT
       ): T | null {
         const validation = validateStorage(key);
         
         if (!validation.valid) {
           console.error(`Storage version ${validation.currentVersion} not supported`);
           return null;
         }

         const raw = localStorage.getItem(key);
         if (!raw) return null;

         // Parse based on detected version
         let parsed: VersionedData<T> | T;
         try {
           parsed = JSON.parse(raw);
         } catch {
           return null;
         }

         // Handle legacy unversioned data
         if (!parsed || typeof (parsed as VersionedData<T>).version !== 'number') {
           // Wrap legacy data
           return runMigration<T>(parsed, 1, targetVersion);
         }

         // Versioned data
         const versioned = parsed as VersionedData<T>;
         if (versioned.version < targetVersion) {
           return runMigration<T>(
             versioned.data, 
             versioned.version, 
             targetVersion
           );
         }

         return versioned.data;
       }
       ```

    5. Create migrations directory with example:
       ```typescript
       // src/shared/lib/storage/migrations/v1-to-v2.ts
       import { registerMigration } from '../migrate';
       import type { ResumeData as V1 } from '../types/v1';
       import type { ResumeData as V2 } from '@/shared/types/resume';

       registerMigration<V1, V2>({
         fromVersion: 1,
         toVersion: 2,
         migrate: (v1) => {
           // Transform v1 data to v2 format
           return {
             ...v1,
             // Add new fields with defaults
             atsOptimized: false,
             lastOptimizedAt: null,
           };
         }
       });
       ```

    6. Export migration utilities from index.ts
  </action>
  <verify>
    1. Migrations compile without errors
    2. Migration chain works for multiple versions
    3. Error handling works for failed migrations
  </verify>
  <done>
    Migration framework implemented with runner, registry, and error handling.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate Versioning into Contexts</name>
  <files>
    src/shared/contexts/ResumeContext.tsx
    src/shared/contexts/JobContext.tsx
  </files>
  <action>
    Update contexts to use versioned storage:

    1. Update ResumeContext save:
       ```typescript
       import { saveVersioned, loadVersioned } from '@/shared/lib/storage';
       
       // In save effect:
       saveVersioned('resumeBuilderDraft', resumeData);
       ```

    2. Update ResumeContext load:
       ```typescript
       // In initialization:
       const saved = loadVersioned<ResumeData>('resumeBuilderDraft');
       if (saved) {
         dispatch({ type: 'LOAD_RESUME', payload: saved });
       }
       ```

    3. Update JobContext similarly:
       ```typescript
       saveVersioned('fjf_job_data', state);
       const saved = loadVersioned<JobState>('fjf_job_data');
       ```

    4. Add migration event logging (dev mode):
       ```typescript
       if (import.meta.env.DEV) {
         console.log(`Storage: Migrated resume from v${fromVersion} to v${toVersion}`);
       }
       ```

    5. Add backup before migration:
       ```typescript
       // Before migration, backup to separate key
       const backupKey = `${key}_backup_v${fromVersion}_${Date.now()}`;
       localStorage.setItem(backupKey, rawData);
       ```

    6. Test migration scenarios:
       - Fresh data (vCURRENT)
       - Legacy data (v1)
       - Missing version field
  </action>
  <verify>
    1. Resume saves with version wrapper
    2. Resume loads and migrates correctly
    3. Backups created before migration
    4. Dev mode shows migration logs
  </verify>
  <done>
    Versioned storage integrated into ResumeContext and JobContext.
    Automatic migration working, backups created.
  </done>
</task>

<task type="auto">
  <name>Task 4: Document Storage Schema</name>
  <files>
    docs/STORAGE_SCHEMA.md
  </files>
  <action>
    Document storage schema for future developers:

    1. Create schema documentation:
       ```markdown
       # Storage Schema

       ## Version History

       | Version | Date | Changes |
       |---------|------|---------|
       | 1 | 2024-01 | Initial schema (unversioned) |
       | 2 | 2024-02 | Added atsOptimized flag, compression |

       ## Keys

       - `resumeBuilderDraft` — Current resume data
       - `fjf_job_data` — Job context data
       - `resumeBuilderSnapshots` — Version history
       - `user_api_key_config` — API keys (session only)

       ## Format

       All data is stored as VersionedData<T>:
       ```json
       {
         "version": 2,
         "migratedAt": "2024-02-12T10:30:00Z",
         "data": { ... }
       }
       ```

       ## Migration Process

       1. Read version from storage
       2. If version < CURRENT, run migrations
       3. Create backup before migration
       4. Save migrated data with new version
       ```

    2. Add migration guide:
       - How to create a new migration
       - Testing migrations
       - Rollback procedures

    3. Document breaking changes policy:
       - When to increment version
       - Backward compatibility requirements
       - Deprecation timeline
  </action>
  <verify>
    1. Documentation complete
    2. Version history accurate
    3. Migration guide clear
  </verify>
  <done>
    Storage schema documented with version history and migration guide.
  </done>
</task>

</tasks>

<verification>
1. Storage version detection works
2. Automatic migration runs on load
3. Backups created before migration
4. No data loss in test scenarios
5. Documentation complete
</verification>

<success_criteria>
- Schema versioning system implemented
- Migration framework with runner and registry
- Contexts use versioned storage
- Automatic migration on version mismatch
- Backups created before migration
- Documentation complete
</success_criteria>

<output>
After completion, create `.planning/phases/00-hardening/00-03-SUMMARY.md`
</output>
