---
phase: 00-hardening
plan: 03
type: execute
wave: 1
depends_on: ['00-02']
files_modified:
  - src/shared/lib/storage/schemaVersion.ts
  - src/shared/lib/storage/migrate.ts
  - src/shared/lib/storage/index.ts
autonomous: true

must_haves:
  truths:
    - Storage schema versioning implemented
    - Migration path is sequential chain (not range filter)
    - Backup created BEFORE every migration
    - No mutation of original objects
    - Migration failures are loud in dev mode
  artifacts:
    - path: "src/shared/lib/storage/schemaVersion.ts"
      provides: "Schema version management"
      exports: ["STORAGE_VERSION", "getStorageVersion"]
    - path: "src/shared/lib/storage/migrate.ts"
      provides: "Sequential migration with backups"
      exports: ["runMigration", "buildMigrationPath"]
  key_links:
    - from: "Storage contexts"
      to: "Migration system"
      via: "loadVersioned()"
---

<objective>
Implement storage versioning with sequential migration chain and mandatory backups.

Purpose: ATS Simulation 2.0 will evolve data structures. Safe migration prevents data loss.
Output: Versioned storage with sequential migrations, automatic backups, no silent failures.
</objective>

<execution_context>
@C:/Users/kittu/.config/opencode/get-shit-done/workflows/execute-plan.md
</execution_context>

<context>
@src/shared/lib/storage/

## Current State
- No schema versioning
- Schema changes = data loss risk
- Types evolving (CoverLetter, JobData, etc.)

## Migration Safety Rules (REVISED)
1. Sequential chain only (buildMigrationPath)
2. Backup before EVERY migration
3. Never mutate original object
4. Always return new object
5. Log migration in dev mode
6. Fail loudly in dev mode

## CRITICAL: Migration Path Logic
DO NOT filter by version range.
Use sequential chain: v1 → v2 → v3 → vCurrent
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Schema Version System</name>
  <files>src/shared/lib/storage/schemaVersion.ts</files>
  <action>
    Create versioning system:

    ```typescript
    // src/shared/lib/storage/schemaVersion.ts
    
    export const STORAGE_VERSION = {
      CURRENT: 2,      // Increment on breaking changes
      MIN_SUPPORTED: 1,
    } as const;

    export type StorageVersion = number;

    export interface VersionedData<T> {
      version: StorageVersion;
      migratedAt?: string;
      data: T;
    }

    export function getStorageVersion(key: string): StorageVersion | null {
      const raw = localStorage.getItem(key);
      if (!raw) return null;
      
      try {
        const parsed = JSON.parse(raw);
        // Check if versioned format
        if (parsed && typeof parsed.version === 'number') {
          return parsed.version;
        }
        // Legacy unversioned data
        return 1;
      } catch {
        return 1;
      }
    }

    export function isVersionSupported(version: StorageVersion): boolean {
      return version >= STORAGE_VERSION.MIN_SUPPORTED && 
             version <= STORAGE_VERSION.CURRENT;
    }

    export function wrapVersioned<T>(data: T, version: number = STORAGE_VERSION.CURRENT): VersionedData<T> {
      return {
        version,
        migratedAt: new Date().toISOString(),
        data
      };
    }
    ```

    Export from index.ts
  </action>
  <verify>
    1. Version detection works for new and legacy data
    2. wrapVersioned() creates correct structure
  </verify>
  <done>
    Schema version system implemented.
    Version detection working.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Sequential Migration Framework (CORRECTED)</name>
  <files>
    src/shared/lib/storage/migrate.ts
    src/shared/lib/storage/migrations/v1-to-v2.ts
  </files>
  <action>
    Create migration system with SEQUENTIAL chain logic:

    ```typescript
    // src/shared/lib/storage/migrate.ts
    
    export interface Migration<TFrom, TTo> {
      fromVersion: number;
      toVersion: number;
      name: string;
      migrate: (data: TFrom) => TTo;
    }

    export class MigrationError extends Error {
      constructor(
        message: string,
        public readonly fromVersion: number,
        public readonly toVersion: number
      ) {
        super(message);
        this.name = 'MigrationError';
      }
    }

    // Migration registry
    const migrations: Migration<unknown, unknown>[] = [];

    export function registerMigration<TFrom, TTo>(
      migration: Migration<TFrom, TTo>
    ): void {
      // Validate no duplicates
      const exists = migrations.find(
        m => m.fromVersion === migration.fromVersion
      );
      if (exists) {
        throw new Error(
          `Migration from v${migration.fromVersion} already registered`
        );
      }
      migrations.push(migration);
    }

    /**
     * Build sequential migration path (CORRECTED)
     * NOT range filter — sequential chain only
     */
    export function buildMigrationPath(
      fromVersion: number,
      toVersion: number
    ): Migration<unknown, unknown>[] {
      if (fromVersion >= toVersion) {
        return []; // No migration needed
      }

      let currentVersion = fromVersion;
      const path: Migration<unknown, unknown>[] = [];

      while (currentVersion < toVersion) {
        const next = migrations.find(
          m => m.fromVersion === currentVersion
        );

        if (!next) {
          throw new MigrationError(
            `No migration path from v${currentVersion}`,
            currentVersion,
            toVersion
          );
        }

        path.push(next);
        currentVersion = next.toVersion;
      }

      return path;
    }

    /**
     * Run migration with MANDATORY backup
     */
    export function runMigration<T>(
      key: string,
      rawData: string,
      fromVersion: number,
      toVersion: number
    ): T {
      // CRITICAL: Create backup BEFORE migration
      const backupKey = `${key}_backup_v${fromVersion}_${Date.now()}`;
      localStorage.setItem(backupKey, rawData);
      
      if (import.meta.env.DEV) {
        console.log(`[Migration] Backup created: ${backupKey}`);
      }

      const path = buildMigrationPath(fromVersion, toVersion);
      
      if (path.length === 0) {
        // Parse and return without migration
        return JSON.parse(rawData).data as T;
      }

      let current: unknown = JSON.parse(rawData).data;

      for (const migration of path) {
        try {
          if (import.meta.env.DEV) {
            console.log(`[Migration] Running: v${migration.fromVersion} → v${migration.toVersion}`);
          }
          
          // CRITICAL: Never mutate original — migrate returns NEW object
          current = migration.migrate(current);
          
        } catch (error) {
          throw new MigrationError(
            `Migration v${migration.fromVersion}→v${migration.toVersion} failed: ${error}`,
            migration.fromVersion,
            migration.toVersion
          );
        }
      }

      return current as T;
    }
    ```

    Create example migration:
    ```typescript
    // src/shared/lib/storage/migrations/v1-to-v2.ts
    import { registerMigration } from '../migrate';
    import type { ResumeData as V1 } from '../types/v1';
    import type { ResumeData as V2 } from '@/shared/types/resume';

    registerMigration<V1, V2>({
      fromVersion: 1,
      toVersion: 2,
      name: 'add-ats-optimized-flag',
      migrate: (v1) => {
        // Return NEW object, never mutate v1
        return {
          ...v1,
          atsOptimized: false,
          lastOptimizedAt: null,
          // Add new fields with defaults
        };
      }
    });
    ```

    Export migrations from index.ts
  </action>
  <verify>
    1. buildMigrationPath creates sequential chain (v1→v2→v3)
    2. No range filtering logic present
    3. Migration creates backup before running
    4. Migration returns new object (no mutation)
  </verify>
  <done>
    Sequential migration framework implemented.
    Backups mandatory, no mutation allowed.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate Versioned Storage into Contexts</name>
  <files>
    src/shared/contexts/ResumeContext.tsx
    src/shared/contexts/JobContext.tsx
  </files>
  <action>
    Update contexts to use versioned storage:

    1. Import versioning:
       ```typescript
       import { 
         wrapVersioned, 
         runMigration, 
         getStorageVersion,
         isVersionSupported 
       } from '@/shared/lib/storage';
       ```

    2. Update save function:
       ```typescript
       function saveResume(data: ResumeData): void {
         const versioned = wrapVersioned(data);
         localStorage.setItem('resumeBuilderDraft', JSON.stringify(versioned));
       }
       ```

    3. Update load function with migration:
       ```typescript
       function loadResume(): ResumeData | null {
         const raw = localStorage.getItem('resumeBuilderDraft');
         if (!raw) return null;

         const currentVersion = getStorageVersion('resumeBuilderDraft');
         
         if (!currentVersion) {
           // Legacy data, treat as v1
           return runMigration<ResumeData>(
             'resumeBuilderDraft',
             raw,
             1,
             STORAGE_VERSION.CURRENT
           );
         }

         if (!isVersionSupported(currentVersion)) {
           console.error(`Storage version ${currentVersion} not supported`);
           return null;
         }

         if (currentVersion < STORAGE_VERSION.CURRENT) {
           return runMigration<ResumeData>(
             'resumeBuilderDraft',
             raw,
             currentVersion,
             STORAGE_VERSION.CURRENT
           );
         }

         // Current version, parse directly
         return JSON.parse(raw).data;
       }
       ```

    4. Add dev mode migration logging:
       ```typescript
       if (import.meta.env.DEV && migrated) {
         console.log(`[Storage] Migrated resume from v${fromVersion} to v${toVersion}`);
       }
       ```

    5. Update JobContext similarly

    6. Test scenarios:
       - Fresh load (current version)
       - Legacy data migration (v1 → v2)
       - Multi-version migration (v1 → v2 → v3)
  </action>
  <verify>
    1. Resume saves with version wrapper
    2. Resume loads and migrates correctly
    3. Backup created before migration
    4. Dev mode shows migration logs
    5. No data loss in test scenarios
  </verify>
  <done>
    Versioned storage integrated.
    Automatic migration working with backups.
  </done>
</task>

<task type="auto">
  <name>Task 4: Document Storage Schema and Migrations</name>
  <files>
    docs/STORAGE_SCHEMA.md
  </files>
  <action>
    Create comprehensive documentation:

    ```markdown
    # Storage Schema

    ## Version History

    | Version | Date | Changes | Migration |
    |---------|------|---------|-----------|
    | 1 | 2024-01 | Initial (unversioned) | - |
    | 2 | 2024-02 | Added atsOptimized flag | v1-to-v2 |

    ## Storage Keys

    - `resumeBuilderDraft` — Current resume (VersionedData<ResumeData>)
    - `fjf_job_data` — Job context (VersionedData<JobState>)
    - `resumeBuilderSnapshots` — Version history

    ## Format

    All data stored as VersionedData<T>:
    ```json
    {
      "version": 2,
      "migratedAt": "2024-02-12T10:30:00Z",
      "data": { ... }
    }
    ```

    ## Migration Process

    1. Read version from storage
    2. If version < CURRENT:
       a. Create backup: `{key}_backup_v{version}_{timestamp}`
       b. Run sequential migrations
       c. Save migrated data with new version
    3. If version unsupported → error (no silent failure)

    ## Creating a Migration

    1. Create file: `src/shared/lib/storage/migrations/v{N}-to-v{N+1}.ts`
    2. Register migration:
       ```typescript
       registerMigration<V{N}, V{N+1}>({
         fromVersion: N,
         toVersion: N+1,
         name: 'description',
         migrate: (old) => {
           // Return NEW object, never mutate old
           return { ...old, newField: defaultValue };
         }
       });
       ```
    3. Update STORAGE_VERSION.CURRENT
    4. Test migration with backup restore

    ## Safety Rules

    - Every migration creates backup first
    - Never mutate original object
    - Fail loudly in dev mode
    - Sequential chain only (no skipping)
    ```

    Save to docs/STORAGE_SCHEMA.md
  </action>
  <verify>
    1. Documentation complete
    2. Version history accurate
    3. Migration examples correct
  </verify>
  <done>
    Storage schema documented.
    Migration process documented.
  </done>
</task>

</tasks>

<verification>
1. Schema versioning implemented
2. Migration path is sequential chain (buildMigrationPath)
3. Backup created before every migration
4. No mutation of original objects
5. Migration failures are loud in dev mode
6. Documentation complete
</verification>

<success_criteria>
- Versioned storage working
- Sequential migration chain
- Mandatory backups
- No object mutation
- Loud failures in dev
- Zero data loss in tests
</success_criteria>

<output>
After completion, create `.planning/phases/00-hardening/00-03-SUMMARY.md`
</output>
