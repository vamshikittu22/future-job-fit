---
phase: 00-hardening
plan: 04
type: execute
wave: 1
depends_on: ['00-03']
files_modified:
  - src/shared/lib/analytics/analytics.ts
  - src/shared/lib/analytics/events.ts
  - src/shared/lib/ai/costTracker.ts
  - src/shared/components/dev/AnalyticsPanel.tsx
autonomous: true

must_haves:
  truths:
    - Analytics captures NO PII ever
    - AI cost tracking has ESTIMATE ONLY disclaimer
    - Budget guardrail warns at $5/session
    - Dev panel shows real-time metrics
    - Events are metadata-only
  artifacts:
    - path: "src/shared/lib/analytics/analytics.ts"
      provides: "PII-free analytics tracking"
      exports: ["trackEvent", "AnalyticsEvent"]
    - path: "src/shared/lib/ai/costTracker.ts"
      provides: "AI cost tracking with estimates"
      exports: ["trackAICall", "getAICostSummary"]
  key_links:
    - from: "ResumeAI service"
      to: "Cost tracker"
      via: "trackAICall()"
---

<objective>
Add analytics and AI cost tracking with strict PII guardrails and budget warnings.

Purpose: ATS Simulation 2.0 will involve heavy AI usage; we need visibility and cost control.
Output: Analytics system (no PII), AI cost tracking (estimates only), budget guardrails.
</objective>

<execution_context>
@C:/Users/kittu/.config/opencode/get-shit-done/workflows/execute-plan.md
</execution_context>

<context>
@src/shared/api/resumeAI.ts

## PII Policy (CRITICAL)
NEVER track:
- Resume content
- Names
- Emails
- Company names
- Job descriptions (raw)

Track metadata ONLY:
- Event types
- Section types
- Provider names
- Token counts (estimated)

## Cost Tracking Rules
1. Token estimates are APPROXIMATE ONLY
2. Add disclaimer in code
3. Warn if session cost > $5
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PII-Free Analytics System</name>
  <files>
    src/shared/lib/analytics/analytics.ts
    src/shared/lib/analytics/events.ts
    src/shared/lib/analytics/index.ts
  </files>
  <action>
    Create analytics with strict PII guardrails:

    ```typescript
    // src/shared/lib/analytics/events.ts
    
    /**
     * Analytics Events - NO PII EVER
     * Track: Actions, metadata, counts
     * NEVER: Content, names, emails, companies
     */
    export enum AnalyticsEvent {
      // Resume events - metadata only
      RESUME_CREATED = 'resume_created',
      RESUME_UPDATED = 'resume_updated',
      SECTION_ADDED = 'section_added',        // type only, not content
      SECTION_EDITED = 'section_edited',      // type only, not content
      TEMPLATE_CHANGED = 'template_changed',  // template name only
      
      // AI events - no prompts, no responses
      AI_ENHANCE_USED = 'ai_enhance_used',           // section_type only
      AI_COVER_LETTER_GENERATED = 'ai_cover_letter_generated',
      AI_ATS_SCORED = 'ai_ats_scored',
      AI_ERROR = 'ai_error',                         // error type only
      
      // Navigation - page names only
      PAGE_VIEW = 'page_view',
      WIZARD_STEP_COMPLETED = 'wizard_step_completed',
      
      // Export - format only
      RESUME_EXPORTED = 'resume_exported',     // format: pdf|docx|etc
    }

    export interface EventProperties {
      // Only safe metadata
      section_type?: string;     // 'experience' | 'education' | etc
      template_name?: string;    // 'modern' | 'professional'
      format?: string;           // 'pdf' | 'docx'
      provider?: string;         // 'gemini' | 'openai'
      step_number?: number;
      error_type?: string;       // 'network' | 'timeout' | 'rate_limit'
      [key: string]: string | number | boolean | undefined;
    }
    ```

    ```typescript
    // src/shared/lib/analytics/analytics.ts
    
    import { AnalyticsEvent, EventProperties } from './events';

    export interface AnalyticsProvider {
      track(event: string, properties?: EventProperties): void;
      identify(userId: string, traits?: Record<string, unknown>): void;
      page(name: string, properties?: EventProperties): void;
    }

    // Console provider for development
    class ConsoleProvider implements AnalyticsProvider {
      track(event: string, properties?: EventProperties): void {
        if (import.meta.env.DEV) {
          console.log('[Analytics]', event, properties);
        }
      }
      
      identify(userId: string): void {
        if (import.meta.env.DEV) {
          console.log('[Analytics] Identify:', userId);
        }
      }
      
      page(name: string, properties?: EventProperties): void {
        if (import.meta.env.DEV) {
          console.log('[Analytics] Page:', name, properties);
        }
      }
    }

    let provider: AnalyticsProvider = new ConsoleProvider();

    export function setAnalyticsProvider(newProvider: AnalyticsProvider): void {
      provider = newProvider;
    }

    /**
     * Track event - NO PII
     * Safe: metadata, types, counts
     * NEVER: content, names, emails
     */
    export function trackEvent(
      event: AnalyticsEvent, 
      properties?: EventProperties
    ): void {
      // Sanitize: ensure no PII in properties
      const safeProperties = sanitizeProperties(properties);
      provider.track(event, safeProperties);
    }

    function sanitizeProperties(
      props?: EventProperties
    ): EventProperties | undefined {
      if (!props) return undefined;
      
      // Remove any potential PII fields
      const { 
        name, email, phone, address, // Remove contact info
        content, text, description,   // Remove content
        company, employer,            // Remove company names
        ...safe 
      } = props as Record<string, unknown>;
      
      return safe;
    }

    export function identifyUser(userId: string): void {
      // Only anonymous ID, never email or name
      provider.identify(userId);
    }

    export function trackPageView(
      pageName: string, 
      properties?: EventProperties
    ): void {
      provider.page(pageName, properties);
    }
    ```

    Export from index.ts
  </action>
  <verify>
    1. No PII fields in EventProperties
    2. sanitizeProperties removes potential PII
    3. Console logging works in dev
  </verify>
  <done>
    PII-free analytics system implemented.
    Sanitization in place.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create AI Cost Tracking with Estimates</name>
  <files>
    src/shared/lib/ai/costTracker.ts
    src/shared/lib/ai/index.ts
  </files>
  <action>
    Create cost tracking with estimate disclaimer and budget guardrail:

    ```typescript
    // src/shared/lib/ai/costTracker.ts
    
    export interface AICallRecord {
      timestamp: string;
      provider: 'gemini' | 'openai' | 'groq';
      model: string;
      operation: string;       // 'enhance' | 'generate' | 'score'
      inputTokens: number;     // ESTIMATED
      outputTokens: number;    // ESTIMATED
      estimatedCost: number;   // USD (estimate only)
      duration: number;        // ms
      success: boolean;
      error?: string;
    }

    // Cost per 1K tokens (approximate)
    const COST_RATES: Record<string, { input: number; output: number }> = {
      'gemini-1.5-flash': { input: 0.00035, output: 0.00105 },
      'gemini-1.5-pro': { input: 0.0035, output: 0.0105 },
      'gpt-4': { input: 0.03, output: 0.06 },
      'gpt-3.5-turbo': { input: 0.0015, output: 0.002 },
      'llama-3.1-70b': { input: 0.00059, output: 0.00079 },
    };

    const callHistory: AICallRecord[] = [];
    const MAX_HISTORY = 1000;
    const BUDGET_WARNING_THRESHOLD = 5.00; // $5 per session

    /**
     * Track AI call with ESTIMATED costs
     * 
     * IMPORTANT: ESTIMATION ONLY
     * Token counts are approximate (1 token ≈ 4 characters for English)
     * Actual costs may vary by ±20%
     */
    export function trackAICall(
      provider: string,
      model: string,
      operation: string,
      inputText: string,
      outputText: string,
      duration: number,
      success: boolean,
      error?: string
    ): AICallRecord {
      // ESTIMATION ONLY — approximate token calculation
      // 1 token ≈ 4 characters (English heuristic)
      // Actual tokenization varies by model and language
      const inputTokens = Math.ceil(inputText.length / 4);
      const outputTokens = Math.ceil(outputText.length / 4);
      
      const rates = COST_RATES[model] || { input: 0.01, output: 0.03 };
      const inputCost = (inputTokens / 1000) * rates.input;
      const outputCost = (outputTokens / 1000) * rates.output;
      
      const record: AICallRecord = {
        timestamp: new Date().toISOString(),
        provider: provider as any,
        model,
        operation,
        inputTokens,      // ESTIMATED
        outputTokens,     // ESTIMATED
        estimatedCost: inputCost + outputCost,  // ESTIMATE ONLY
        duration,
        success,
        error
      };

      callHistory.push(record);
      if (callHistory.length > MAX_HISTORY) {
        callHistory.shift();
      }

      // Budget guardrail
      const sessionCost = getCurrentSessionCost();
      if (sessionCost > BUDGET_WARNING_THRESHOLD) {
        console.warn(
          `⚠️ AI cost exceeded $${BUDGET_WARNING_THRESHOLD} this session. ` +
          `Current: $${sessionCost.toFixed(2)}`
        );
      }

      // Dev logging
      if (import.meta.env.DEV) {
        console.log(
          `[AI Cost] ${operation}: ~$${record.estimatedCost.toFixed(4)} ` +
          `(~${inputTokens} → ~${outputTokens} tokens, ESTIMATED)`
        );
      }

      return record;
    }

    export interface AICostSummary {
      totalCalls: number;
      successfulCalls: number;
      failedCalls: number;
      totalCost: number;           // ESTIMATED
      totalInputTokens: number;    // ESTIMATED
      totalOutputTokens: number;   // ESTIMATED
      averageDuration: number;
      callsByOperation: Record<string, number>;
    }

    export function getAICostSummary(options?: {
      since?: Date;
      operation?: string;
    }): AICostSummary {
      let filtered = [...callHistory];
      
      if (options?.since) {
        filtered = filtered.filter(c => 
          new Date(c.timestamp) >= options.since!
        );
      }
      if (options?.operation) {
        filtered = filtered.filter(c => 
          c.operation === options.operation
        );
      }

      const totalCalls = filtered.length;
      const successfulCalls = filtered.filter(c => c.success).length;
      
      const callsByOperation: Record<string, number> = {};
      filtered.forEach(c => {
        callsByOperation[c.operation] = (callsByOperation[c.operation] || 0) + 1;
      });

      return {
        totalCalls,
        successfulCalls,
        failedCalls: totalCalls - successfulCalls,
        totalCost: filtered.reduce((sum, c) => sum + c.estimatedCost, 0),
        totalInputTokens: filtered.reduce((sum, c) => sum + c.inputTokens, 0),
        totalOutputTokens: filtered.reduce((sum, c) => sum + c.outputTokens, 0),
        averageDuration: totalCalls > 0 
          ? filtered.reduce((sum, c) => sum + c.duration, 0) / totalCalls 
          : 0,
        callsByOperation
      };
    }

    export function getCurrentSessionCost(): number {
      const sessionStart = sessionStorage.getItem('ai_session_start');
      const since = sessionStart ? new Date(sessionStart) : new Date();
      return getAICostSummary({ since }).totalCost;
    }

    export function initAISession(): void {
      if (!sessionStorage.getItem('ai_session_start')) {
        sessionStorage.setItem('ai_session_start', new Date().toISOString());
      }
    }
    ```

    Export from index.ts
  </action>
  <verify>
    1. ESTIMATION ONLY comment in all relevant places
    2. Token calculation uses /4 heuristic
    3. Budget warning at $5
    4. Dev logging shows estimates
  </verify>
  <done>
    AI cost tracking with estimate disclaimers.
    Budget guardrail in place.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate Tracking into ResumeAI Service</name>
  <files>src/shared/api/resumeAI.ts</files>
  <action>
    Wire up cost tracking to ResumeAI service:

    1. Import trackers:
       ```typescript
       import { trackAICall, initAISession } from '@/shared/lib/ai/costTracker';
       import { trackEvent, AnalyticsEvent } from '@/shared/lib/analytics';
       
       initAISession();
       ```

    2. Track enhanceSection:
       ```typescript
       async enhanceSection(request: EnhanceRequest): Promise<EnhanceResponse> {
         const startTime = performance.now();
         
         try {
           const response = await this.makeRequest('enhance', request);
           const duration = performance.now() - startTime;
           
           // Track cost (ESTIMATED)
           trackAICall(
             this.provider,
             this.model,
             'enhance_section',
             request.original_text,           // For token estimation
             JSON.stringify(response.variants), // For token estimation
             duration,
             true
           );
           
           // Track event (metadata only, no content)
           trackEvent(AnalyticsEvent.AI_ENHANCE_USED, {
             section_type: request.section_type,  // Safe: type only
             provider: this.provider,              // Safe: provider name
             demo_mode: this.isDemoMode
           });
           
           return response;
         } catch (error) {
           const duration = performance.now() - startTime;
           trackAICall(
             this.provider,
             this.model,
             'enhance_section',
             request.original_text,
             '',
             duration,
             false,
             String(error)
           );
           
           trackEvent(AnalyticsEvent.AI_ERROR, {
             operation: 'enhance_section',
             error_type: this.categorizeError(error)
           });
           
           throw error;
         }
       }
       ```

    3. Add error categorization:
       ```typescript
       private categorizeError(error: unknown): string {
         const message = String(error).toLowerCase();
         if (message.includes('timeout')) return 'timeout';
         if (message.includes('rate')) return 'rate_limit';
         if (message.includes('network')) return 'network';
         return 'unknown';
       }
       ```

    4. Wire up other AI methods similarly
  </action>
  <verify>
    1. AI calls tracked with estimates
    2. Analytics events fire (metadata only)
    3. Budget warning appears if >$5
  </verify>
  <done>
    ResumeAI integrated with tracking.
    Events and costs captured.
  </done>
</task>

<task type="auto">
  <name>Task 4: Add God Mode Analytics Panel</name>
  <files>
    src/shared/components/dev/AnalyticsPanel.tsx
  </files>
  <action>
    Create analytics panel for God Mode (triple-click "AI" in header):

    ```typescript
    // src/shared/components/dev/AnalyticsPanel.tsx
    import { useState, useEffect } from 'react';
    import { getAICostSummary, getCurrentSessionCost } from '@/shared/lib/ai/costTracker';

    export function AnalyticsPanel() {
      const [summary, setSummary] = useState(getAICostSummary());
      
      useEffect(() => {
        const interval = setInterval(() => {
          setSummary(getAICostSummary());
        }, 5000);
        return () => clearInterval(interval);
      }, []);

      const sessionCost = getCurrentSessionCost();
      const overBudget = sessionCost > 5;

      return (
        <div className="space-y-4 font-mono text-sm">
          <h3 className="font-bold text-amber-400">AI Usage (ESTIMATES)</h3>
          
          <div className="grid grid-cols-2 gap-2">
            <div>Session Cost:</div>
            <div className={overBudget ? 'text-red-400 font-bold' : ''}>
              ${sessionCost.toFixed(4)}
              {overBudget && ' ⚠️'}
            </div>
            
            <div>Total Cost:</div>
            <div>${summary.totalCost.toFixed(4)}</div>
            
            <div>Total Calls:</div>
            <div>{summary.totalCalls}</div>
            
            <div>Success Rate:</div>
            <div>
              {summary.totalCalls > 0 
                ? ((summary.successfulCalls / summary.totalCalls) * 100).toFixed(1)
                : 0}%
            </div>
            
            <div>Est. Tokens:</div>
            <div>
              {summary.totalInputTokens.toLocaleString()} → {summary.totalOutputTokens.toLocaleString()}
            </div>
          </div>

          <p className="text-xs text-gray-500 mt-2">
            ⚠️ Token counts and costs are ESTIMATES ONLY (~±20% accuracy)
          </p>

          <h4 className="font-semibold text-amber-400 mt-4">By Operation</h4>
          {Object.entries(summary.callsByOperation).map(([op, count]) => (
            <div key={op} className="flex justify-between">
              <span>{op}:</span>
              <span>{count}</span>
            </div>
          ))}
        </div>
      );
    }
    ```

    Integrate into existing God Mode console.
  </action>
  <verify>
    1. Panel renders in God Mode
    2. Costs update in real-time
    3. Warning shows if >$5
    4. Estimate disclaimer visible
  </verify>
  <done>
    God Mode analytics panel working.
    Real-time cost tracking visible.
  </done>
</task>

</tasks>

<verification>
1. Analytics captures NO PII (verify sanitizeProperties)
2. AI cost tracking has ESTIMATE ONLY disclaimer
3. Budget guardrail warns at $5/session
4. Dev panel shows metrics
5. Events are metadata-only
</verification>

<success_criteria>
- PII-free analytics (verified)
- Cost tracking with estimate disclaimer
- Budget warning at $5
- God Mode panel working
- No content in tracked events
</success_criteria>

<output>
After completion, create `.planning/phases/00-hardening/00-04-SUMMARY.md`
</output>
